#include "DisplayMessageNumsLabel.h"

#include <QDrag>
#include <QApplication>
#include <QPainter>
#include <QMouseEvent>
#include <QMimeData>
#include <QDebug>
#include <QtGlobal>

/**
 *该类为一个利用painter绘图显示消息数的label
 *实现思路：
 * 1. 通过重载paintEvent来实现自定义绘制
 * 2. 通过信号槽机制来实现消息计数器的更新
 * 当私有原子变量有值的时候那么painter绘制消息计数器
 * 如果没有值那么不绘制
 * 并且该类还要支持拖动功能
 * 将该类设置为可被拖拽的对象
 * 拖拽的图片为我们绘制的消息计数器图片
 * 那么我们只需要监听拖拽出事件即可
 * 和拖动开始事件，利用QPainter将消息计数器绘制到一个pixmap上然后将该pixmap设置为拖动图像
 * 当鼠标按下时记录拖动开始位置并且通过mouseMoveEvent来判断是否移动距离超过拖动距离
 * 如果超过则开始拖动
 */
DisplayMessageNumsLabel::DisplayMessageNumsLabel(QWidget* parent):ClickedLabel(parent),the_message_nums_m(0)
{
	connect(this,&DisplayMessageNumsLabel::sig_increment_message_nums,this,&DisplayMessageNumsLabel::slot_increment_message_nums);
}


void DisplayMessageNumsLabel::clear_message_nums()
{
	this->the_message_nums_m.store(0, std::memory_order_release);
	this->update();
}

void DisplayMessageNumsLabel::set_message_nums(unsigned char count)
{
	this->the_message_nums_m.store(count, std::memory_order_release);
	if (count > 0) {
		this->setVisible(true);
	} else {
		this->setVisible(false);
	}
	this->update();
}

unsigned char DisplayMessageNumsLabel::get_message_nums() const
{
	return  this->the_message_nums_m.load(std::memory_order_acquire);
}


void DisplayMessageNumsLabel::increment_message_nums()
{
	this->the_message_nums_m.fetch_add(1, std::memory_order_acq_rel);
	this->setVisible(true);
	this->update();
}


void DisplayMessageNumsLabel::paintEvent(QPaintEvent* event)
{
    if (this->the_message_nums_m.load(std::memory_order_acquire) == 0)
    {
		ClickedLabel::paintEvent(event);
        return; // 没有消息时不绘制任何内容
    }

	ClickedLabel::paintEvent(event);
    // 消息数大于0时绘制圆和数字
	QRect painter_rect = this->rect();//获取当前label的矩形然后在其的右上角的位置然后获取设置圆点
	QPoint the_circle_center = painter_rect.bottomRight();
	int the_circle_center_x = the_circle_center.x() -20;
	int the_circle_center_y = the_circle_center.y() -20;
	the_circle_center = QPoint(the_circle_center_x, the_circle_center_y);//圆心的位置
	int the_circle_radius = 5;//圆的半径
	QFont the_font = this->font();
	the_font.setPointSize(10);
	QPainter painter(this);
	painter.setRenderHint(QPainter::Antialiasing, true);//抗锯齿
	painter.setBrush(QBrush(Qt::red));
	painter.setPen(Qt::NoPen);
	painter.setFont(the_font);
	painter.drawEllipse(the_circle_center, the_circle_radius * 2, the_circle_radius * 2);//绘制圆
	painter.setPen(Qt::white);
	QString message_count_str = QString::number(this->the_message_nums_m.load(std::memory_order_acquire));
	painter.drawText(QRect(the_circle_center.x() - the_circle_radius, the_circle_center.y() - the_circle_radius, the_circle_radius * 2, the_circle_radius * 2),
		Qt::AlignCenter, message_count_str);//绘制数字

}

void DisplayMessageNumsLabel::mouseMoveEvent(QMouseEvent* event)
{
	if (event->buttons() == Qt::LeftButton &&
		(event->pos() - this->drag_start_position_m).manhattanLength() > QApplication::startDragDistance()
		&&this->the_message_nums_m.load(std::memory_order_acquire)!=0)
	{
		QDrag* drag = new QDrag(this);
		QMimeData* mimeData = new QMimeData;
		mimeData->setText(QString::number(this->the_message_nums_m.load(std::memory_order_acquire))); //
		drag->setMimeData(mimeData);

		QPixmap pixmap = this->get_notify_pixmap();
		this->clear_message_nums();//拖拽开始就清零消息计数器
		drag->setPixmap(pixmap);
		drag->setHotSpot(QPoint(pixmap.width() / 2, pixmap.height() / 2));
		drag->exec(Qt::IgnoreAction);
	}
}


void DisplayMessageNumsLabel::mousePressEvent(QMouseEvent* event)
{
	this->drag_start_position_m = event->pos();
	ClickedLabel::mousePressEvent(event);
}


void DisplayMessageNumsLabel::slot_increment_message_nums()
{
	this->the_message_nums_m.fetch_add(1, std::memory_order_acq_rel);
	this->update();
}







QPixmap DisplayMessageNumsLabel::get_notify_pixmap()//获取绘制的消息计数器图片
{
	QRect painter_rect = this->rect();//获取当前label的矩形然后在其的右上角的位置然后获取设置圆点
	QPoint the_circle_center = painter_rect.bottomRight();
	int the_circle_center_x = the_circle_center.x() - 20;
	int the_circle_center_y = the_circle_center.y() - 20;
	the_circle_center = QPoint(the_circle_center_x, the_circle_center_y);//圆心的位置
	int the_circle_radius = 5;//圆的半径
	QFont the_font = this->font();
	the_font.setPointSize(10);
	QPixmap pixmap(painter_rect.size());
	pixmap.fill(Qt::transparent); // 填充透明背景
	QPainter painter(&pixmap);
	painter.setRenderHint(QPainter::Antialiasing, true);//抗锯齿
	painter.setBrush(QBrush(Qt::red));
	painter.setPen(Qt::NoPen);
	painter.setFont(the_font);
	painter.drawEllipse(the_circle_center, the_circle_radius * 2, the_circle_radius * 2);//绘制圆
	painter.setPen(Qt::white);
	QString message_count_str = QString::number(this->the_message_nums_m.load(std::memory_order_acquire));
	painter.drawText(QRect(the_circle_center.x() - the_circle_radius, the_circle_center.y() - the_circle_radius, the_circle_radius * 2, the_circle_radius * 2),
		Qt::AlignCenter, message_count_str);//绘制数字
	return pixmap;
}


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































